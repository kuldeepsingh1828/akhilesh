class ColumnViewReact extends React.Component<{}, StateModel> {
    columnviewdata: any; displayColumnView: any; isNetAssets: boolean; constructor(props: ColumnViewProps) { super(props); this.state = { filteredData: null } if (props.netassetdata) { this.isNetAssets = true; this.columnviewdata = this.mapNetAssetStructure(props.netassetdata) } else if (props.dailypricingdata) { this.isNetAssets = false; this.columnviewdata = props.dailypricingdata.account.dailyPricing; } } componentDidMount(): void { this.setState({ filteredData: this.columnviewdata }); } componentDidUpdate(): void { }

    render() { let columnHeading = this.getColumnHeading(this.props); let asOfDate = this.state.filteredData ? this.state.filteredData.asOf : null; this.displayColumnView = this.state.filteredData ? this.formatData(this.state.filteredData) : null; return (<div className={"column-view-container"}> <div className={"heading-container"}> <h1>{columnHeading} <span className={"as-of-text"}>(as of {asOfDate})</span></h1> </div> <div className={"data-container"}> <div className={"data-row"}> {this.displayColumnView} </div> </div> </div>) } filterData(classId, columnviewdata) { return columnviewdata.find(c => c.class.class_id === classId); } mapDailyPricingStructure(dailyPricingData) { let obj = dailyPricingData.map(data => ({ class: data.class, data: data.daily_pricing })); return obj; } mapNetAssetStructure(props) {
        let netAsset: ColumnDetail = { value: this.getDecimalMatrix(props.total_net_assets.value) }; let asset: DataStructure = { as_of_date: props.total_net_assets.as_of_date, net_asset: netAsset }; let obj: Clas


        getDecimalMatrix(num: number) { let roundUptoDigits = 1; let textArray = [{ value: 1, text: "" }, { value: 1E3, text: "thousand" }, { value: 1E6, text: "million" }, { value: 1E9, text: "billion" }, { value: 1E12, text: "trillion" }]; let reg = /\.0+$|(\.[0-9]*[1-9])0+$/; let index; for (index = textArray.length - 1; index > 0; index--) { if (num >= textArray[index].value) { break; } } let ex = '$' + ((num / textArray[index].value).toFixed(roundUptoDigits).replace(reg, "$1")) + ' ' + textArray[index].text; return ex; } getColumnHeading(props) { let columnHeading = ''; if (props.netassetdata) { columnHeading = ColumnViewHeadingEnum.TOTAL_NET_ASSETS; } else if (props.dailypricingdata) { columnHeading = ColumnViewHeadingEnum.DAILY_PRICING; } return columnHeading; } formatData(filteredData: ClassColumnView) {
            let sectionHeaders; let displayColumnView; if (filteredData) {
                displayColumnView = Object.entries(filteredData).map(sections => {
                    if (sections[0] != 'asOf') sectionHeaders = this.getSectionHeaders(sections[


    return displayColumnView;
                } getValues(value, sectionHeader) { if(sectionHeader == NavEnum.NET_CHANGE) { let val = parseFloat(value); if (val < 0) { return <span className={"negative-pricing"}>{'$' + parseFloat(value).toFixed(2)}</span>; } else { return (parseFloat(value).toFixed(2)  '0.00' || parseFloat(value).toFixed(2)  '-0.00') ?<span className={"normal-pricing"}>No change</span> : <span className={"normal-pricing"}>{'$' + parseFloat(value).toFixed(2)}</span>; } } else if (sectionHeader == NetAssetEnum.VALUE) { return <span>{value}</span>; } return <span>{'$' + parseFloat(value).toFixed(2)}</span>;
            } getSectionHeaders(parentHeader, childHeader = null) { if (parentHeader  ColumnViewSectionKeysEnum.NAV) { switch (childHeader) { case ColumnViewKeysEnum.NET_CHANGE: return NavEnum.NET_CHANGE; case ColumnViewKeysEnum.PRICE: return NavEnum.PRICE; } } else if (parentHeader  ColumnViewSectionKeysEnum.MAX_OFFER_PRICE) { switch (childHeader) { case ColumnViewKeysEnum.PRICE: return MaxOfferEnum.PRICE; } } else

    getSectionHeaders(parentHeader, childHeader = null) { if (parentHeader  ColumnViewSectionKeysEnum.NAV) { switch (childHeader) { case ColumnViewKeysEnum.NET_CHANGE: return NavEnum.NET_CHANGE; case ColumnViewKeysEnum.PRICE: return NavEnum.PRICE; } } else if (parentHeader  ColumnViewSectionKeysEnum.MAX_OFFER_PRICE) { switch (childHeader) { case ColumnViewKeysEnum.PRICE: return MaxOfferEnum.PRICE; } } else if (parentHeader == ColumnViewSectionKeysEnum.NET_ASSET) { switch (childHeader) { case ColumnViewKeysEnum.VALUE: return NetAssetEnum.VALUE; } } else { var column = { 'value': ColumnViewHeadingEnum.TOTAL_NET_ASSETS, "nav": MaxOfferEnum.NET_CHANGE, "nav1Day": NavEnum.NET_CHANGE, "mktPrice": MarketPriceEnum.PRICE, "mktPrice1Day": MarketPriceEnum.PRICE_1_DAY } if (column[parentHeader]) return column[parentHeader] return null; } }
} export default ColumnViewReact;